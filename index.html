<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Rubik's Cube Solver</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=Sora:wght@300;400;600;800&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
:root {
  --bg: #f4f1eb;
  --surface: #fff;
  --border: #e0dbd2;
  --text: #1a1714;
  --text-dim: #8a857c;
  --accent: #c43e1c;
  --accent2: #1a6b4a;
}
html{font-size:16px}
body{
  background:var(--bg);
  color:var(--text);
  font-family:'Sora',sans-serif;
  height:100vh;height:100dvh;
  overflow:hidden;
  user-select:none;
  -webkit-user-select:none;
}
body::before{
  content:'';position:fixed;inset:0;
  background-image:url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23000' fill-opacity='0.02'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
  pointer-events:none;z-index:0;
}
.layout{
  display:flex;flex-direction:column;
  height:100vh;height:100dvh;
  position:relative;z-index:1;
  overflow:hidden;
}
.header{padding:0.6rem 1rem 0.2rem;text-align:center;flex-shrink:0}
.header h1{
  font-family:'DM Mono',monospace;
  font-size:clamp(1.1rem,3vw,1.8rem);
  font-weight:500;letter-spacing:-0.03em;
}
.header h1 span{color:var(--accent)}
.header .sub{
  font-size:0.6rem;color:var(--text-dim);
  letter-spacing:0.2em;text-transform:uppercase;margin-top:0.05rem;
}
.info-bar{
  display:flex;align-items:center;justify-content:center;
  gap:1rem;padding:0.2rem 0.5rem;flex-shrink:0;
  flex-wrap:wrap;
}
.stat{font-family:'DM Mono',monospace;font-size:0.65rem;color:var(--text-dim)}
.stat span{color:var(--accent);font-weight:500}
.arrow-inline{display:flex;align-items:center;gap:0.3rem}
.arrow-inline .arrow-svg{width:30px;height:30px}
.arrow-inline .arrow-label{
  font-family:'DM Mono',monospace;font-size:0.8rem;font-weight:600;color:var(--accent);
}
.arrow-inline .arrow-desc{
  font-family:'Sora',sans-serif;font-size:0.58rem;color:var(--text-dim);
}
.move-display{
  font-family:'DM Mono',monospace;font-size:0.7rem;
  color:var(--text-dim);text-align:center;
  padding:0.1rem 0.5rem;flex-shrink:0;
  display:flex;align-items:center;justify-content:center;gap:0.2rem;
  flex-wrap:wrap;min-height:1.5em;
}
.mv{
  display:inline-flex;align-items:center;justify-content:center;
  padding:0.12rem 0.3rem;border-radius:3px;
  font-size:0.6rem;transition:all 0.2s;
}
.mv.done{background:#e8e6e0;color:var(--text-dim);opacity:0.5}
.mv.current{
  background:var(--accent);color:#fff;
  font-weight:600;font-size:0.7rem;
  box-shadow:0 1px 6px rgba(196,62,28,0.3);
  transform:scale(1.1);
}
.mv.future{background:#eae7e0;color:var(--text-dim)}
#cubeCanvas{
  display:block;cursor:grab;
  flex:1;min-height:0;width:100%;
}
#cubeCanvas:active{cursor:grabbing}
.controls{
  display:flex;flex-wrap:wrap;justify-content:center;
  align-items:center;gap:0.5rem;
  padding:0.4rem 0.5rem;flex-shrink:0;
  padding-bottom:max(0.4rem, env(safe-area-inset-bottom));
}
.ctrl-group{display:flex;flex-direction:column;align-items:center;gap:0.15rem}
.ctrl-group label{
  font-family:'DM Mono',monospace;font-size:0.52rem;
  color:var(--text-dim);text-transform:uppercase;letter-spacing:0.15em;
}
.btn{
  font-family:'DM Mono',monospace;font-size:0.68rem;letter-spacing:0.03em;
  padding:0.45rem 0.75rem;border:1.5px solid var(--border);
  background:var(--surface);color:var(--text);border-radius:6px;
  cursor:pointer;transition:all 0.2s;
  -webkit-tap-highlight-color:transparent;
  touch-action:manipulation;
}
.btn:hover{border-color:var(--accent);color:var(--accent)}
.btn:active{transform:scale(0.96)}
.btn:disabled{opacity:0.3;cursor:not-allowed;transform:none}
.btn--accent{background:var(--accent);color:#fff;border-color:var(--accent)}
.btn--accent:hover{background:#a83518;border-color:#a83518;color:#fff}
.btn--green{background:var(--accent2);color:#fff;border-color:var(--accent2)}
.btn--green:hover{background:#145a3e;border-color:#145a3e;color:#fff}
.slider-wrap{display:flex;align-items:center;gap:0.4rem}
.speed-slider{
  -webkit-appearance:none;appearance:none;
  width:90px;height:3px;background:var(--border);border-radius:2px;outline:none;
}
.speed-slider::-webkit-slider-thumb{
  -webkit-appearance:none;width:20px;height:20px;border-radius:50%;
  background:var(--accent);cursor:pointer;
  box-shadow:0 1px 4px rgba(196,62,28,0.3);
}
.speed-val{
  font-family:'DM Mono',monospace;font-size:0.62rem;color:var(--accent);
  min-width:4ch;text-align:center;
}
.step-row{display:flex;gap:0.3rem}

@media(max-width:480px){
  .header{padding:0.4rem 0.5rem 0.15rem}
  .header .sub{display:none}
  .controls{gap:0.3rem;padding:0.35rem 0.3rem}
  .btn{padding:0.4rem 0.55rem;font-size:0.6rem}
  .speed-slider{width:70px}
  .move-display{font-size:0.58rem;padding:0.05rem 0.3rem}
  .mv{padding:0.08rem 0.2rem;font-size:0.52rem}
  .mv.current{font-size:0.6rem}
  .info-bar{gap:0.4rem;padding:0.15rem}
}
@media(max-height:500px){
  .header h1{font-size:1rem}
  .header{padding:0.2rem 0.5rem 0.05rem}
  .header .sub{display:none}
  .info-bar{padding:0.1rem}
  .move-display{min-height:1em;padding:0.02rem}
  .controls{padding:0.2rem}
}
</style>
</head>
<body>
<div class="layout">
  <div class="header">
    <h1>Rubik's <span>Cube</span></h1>
    <div class="sub">3×3 Solver &amp; Visualizer</div>
  </div>
  <div class="info-bar">
    <div class="stat">Status: <span id="statusText">Ready</span></div>
    <div class="stat">Moves: <span id="moveIdx">0</span>/<span id="moveTotal">0</span></div>
    <div class="arrow-inline" id="arrowBox"></div>
  </div>
  <div class="move-display" id="moveDisplay"></div>
  <canvas id="cubeCanvas"></canvas>
  <div class="controls">
    <div class="ctrl-group">
      <label>Speed</label>
      <div class="slider-wrap">
        <input type="range" class="speed-slider" id="speedSlider" min="1" max="10" value="4">
        <div class="speed-val" id="speedVal">0.8s</div>
      </div>
    </div>
    <button class="btn" id="scrambleBtn">Scramble</button>
    <button class="btn btn--accent" id="solveBtn" disabled>Solve</button>
    <div class="step-row">
      <button class="btn" id="stepBackBtn" disabled>◀</button>
      <button class="btn" id="stepBtn" disabled>▶</button>
    </div>
    <button class="btn btn--green" id="resetBtn">Reset</button>
  </div>
</div>

<script>
const COLORS = {
  W: 0xffffff, Y: 0xffd426, R: 0xc41e3a,
  O: 0xff5800, B: 0x0051ba, G: 0x009e60, X: 0x1a1714
};

const canvas = document.getElementById('cubeCanvas');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setClearColor(0x000000, 0);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 100);
camera.position.set(5, 4, 6);
camera.lookAt(0,0,0);

scene.add(new THREE.AmbientLight(0xffffff, 0.65));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
dirLight.position.set(5,8,6);
scene.add(dirLight);

const GAP = 0.06;
const CUBIE_SIZE = 0.874; // 0.92 * 0.95 = 95% size
const cubies = [];
const cubieMeshes = new THREE.Group();
scene.add(cubieMeshes);

function makeCubieMaterials(ix, iy, iz){
  return [
    new THREE.MeshStandardMaterial({color: ix===1 ? COLORS.G : COLORS.X}),
    new THREE.MeshStandardMaterial({color: ix===-1 ? COLORS.B : COLORS.X}),
    new THREE.MeshStandardMaterial({color: iy===1 ? COLORS.W : COLORS.X}),
    new THREE.MeshStandardMaterial({color: iy===-1 ? COLORS.Y : COLORS.X}),
    new THREE.MeshStandardMaterial({color: iz===1 ? COLORS.R : COLORS.X}),
    new THREE.MeshStandardMaterial({color: iz===-1 ? COLORS.O : COLORS.X}),
  ];
}

const SPACING = 0.95 + GAP; // tighter spacing to match smaller cubie

function buildCube(){
  while(cubieMeshes.children.length) cubieMeshes.remove(cubieMeshes.children[0]);
  cubies.length = 0;
  const geo = new THREE.BoxGeometry(CUBIE_SIZE, CUBIE_SIZE, CUBIE_SIZE);
  for(let x=-1;x<=1;x++)
    for(let y=-1;y<=1;y++)
      for(let z=-1;z<=1;z++){
        const mesh = new THREE.Mesh(geo, makeCubieMaterials(x,y,z));
        mesh.position.set(x*SPACING, y*SPACING, z*SPACING);
        cubieMeshes.add(mesh);
        cubies.push({mesh, ix:x, iy:y, iz:z});
      }
}

let isAnimating = false;
const rotationGroup = new THREE.Group();
scene.add(rotationGroup);

function getLayerCubies(axis, layer){
  return cubies.filter(c => {
    if(axis==='x') return c.ix === layer;
    if(axis==='y') return c.iy === layer;
    return c.iz === layer;
  });
}

function animateLayerRotation(axis, layer, angleDeg, duration){
  return new Promise(resolve => {
    if(isAnimating){resolve();return;}
    isAnimating = true;
    const affected = getLayerCubies(axis, layer);
    rotationGroup.rotation.set(0,0,0);
    rotationGroup.position.set(0,0,0);
    affected.forEach(c => { cubieMeshes.remove(c.mesh); rotationGroup.add(c.mesh); });
    const angleRad = THREE.MathUtils.degToRad(angleDeg);
    const axisVec = axis==='x'?new THREE.Vector3(1,0,0):axis==='y'?new THREE.Vector3(0,1,0):new THREE.Vector3(0,0,1);
    const startTime = performance.now();
    function tick(){
      const t = Math.min((performance.now()-startTime)/duration, 1);
      const ease = 1-Math.pow(1-t,3);
      rotationGroup.rotation.set(0,0,0);
      rotationGroup.rotateOnAxis(axisVec, angleRad*ease);
      if(t<1){ requestAnimationFrame(tick); return; }
      rotationGroup.rotation.set(0,0,0);
      rotationGroup.rotateOnAxis(axisVec, angleRad);
      rotationGroup.updateMatrixWorld(true);
      affected.forEach(c => {
        const wp=new THREE.Vector3(); c.mesh.getWorldPosition(wp);
        const wq=new THREE.Quaternion(); c.mesh.getWorldQuaternion(wq);
        rotationGroup.remove(c.mesh); cubieMeshes.add(c.mesh);
        c.mesh.position.copy(wp); c.mesh.quaternion.copy(wq);
        c.ix=Math.round(wp.x/SPACING); c.iy=Math.round(wp.y/SPACING); c.iz=Math.round(wp.z/SPACING);
      });
      rotationGroup.rotation.set(0,0,0);
      isAnimating=false; resolve();
    }
    requestAnimationFrame(tick);
  });
}

const MOVE_MAP = {
  'U':{axis:'y',layer:1,angle:-90},"U'":{axis:'y',layer:1,angle:90},'U2':{axis:'y',layer:1,angle:-180},
  'D':{axis:'y',layer:-1,angle:90},"D'":{axis:'y',layer:-1,angle:-90},'D2':{axis:'y',layer:-1,angle:180},
  'F':{axis:'z',layer:1,angle:-90},"F'":{axis:'z',layer:1,angle:90},'F2':{axis:'z',layer:1,angle:-180},
  'B':{axis:'z',layer:-1,angle:90},"B'":{axis:'z',layer:-1,angle:-90},'B2':{axis:'z',layer:-1,angle:180},
  'R':{axis:'x',layer:1,angle:-90},"R'":{axis:'x',layer:1,angle:90},'R2':{axis:'x',layer:1,angle:-180},
  'L':{axis:'x',layer:-1,angle:90},"L'":{axis:'x',layer:-1,angle:-90},'L2':{axis:'x',layer:-1,angle:180},
};

async function executeMove(notation, duration){
  const m=MOVE_MAP[notation]; if(!m)return;
  await animateLayerRotation(m.axis, m.layer, m.angle, duration);
}

let orbiting=false, orbX, orbY;
let cameraTheta=Math.PI/4, cameraPhi=Math.PI/6;
const cameraRadius=8.5;

function updateCamera(){
  camera.position.x=cameraRadius*Math.cos(cameraPhi)*Math.sin(cameraTheta);
  camera.position.y=cameraRadius*Math.sin(cameraPhi);
  camera.position.z=cameraRadius*Math.cos(cameraPhi)*Math.cos(cameraTheta);
  camera.lookAt(0,0,0);
}

canvas.addEventListener('mousedown',e=>{orbiting=true;orbX=e.clientX;orbY=e.clientY});
window.addEventListener('mousemove',e=>{
  if(!orbiting)return;
  cameraTheta+=(e.clientX-orbX)*0.008; cameraPhi+=(e.clientY-orbY)*0.008;
  cameraPhi=Math.max(-Math.PI/3,Math.min(Math.PI/3,cameraPhi));
  orbX=e.clientX;orbY=e.clientY; updateCamera();
});
window.addEventListener('mouseup',()=>{orbiting=false});
canvas.addEventListener('touchstart',e=>{
  if(e.touches.length===1){orbiting=true;orbX=e.touches[0].clientX;orbY=e.touches[0].clientY}
},{passive:true});
window.addEventListener('touchmove',e=>{
  if(!orbiting||e.touches.length!==1)return;
  cameraTheta+=(e.touches[0].clientX-orbX)*0.008;
  cameraPhi+=(e.touches[0].clientY-orbY)*0.008;
  cameraPhi=Math.max(-Math.PI/3,Math.min(Math.PI/3,cameraPhi));
  orbX=e.touches[0].clientX;orbY=e.touches[0].clientY; updateCamera();
},{passive:true});
window.addEventListener('touchend',()=>{orbiting=false});

function resize(){
  const rect = canvas.getBoundingClientRect();
  const w = rect.width, h = rect.height;
  if(w===0||h===0) return;
  const dpr = Math.min(window.devicePixelRatio, 2);
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  renderer.setSize(w, h);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', resize);

function renderLoop(){ requestAnimationFrame(renderLoop); renderer.render(scene, camera); }

const arrowBox = document.getElementById('arrowBox');
const MOVE_DESC = {
  'U':'Top CW',"U'":'Top CCW','U2':'Top 180°',
  'D':'Bottom CW',"D'":'Bottom CCW','D2':'Bottom 180°',
  'F':'Front CW',"F'":'Front CCW','F2':'Front 180°',
  'B':'Back CW',"B'":'Back CCW','B2':'Back 180°',
  'R':'Right CW',"R'":'Right CCW','R2':'Right 180°',
  'L':'Left CW',"L'":'Left CCW','L2':'Left 180°',
};

function getArrowSVG(notation){
  const is180=notation.includes('2'), isPrime=notation.includes("'"), face=notation[0];
  const faceColors={U:'#888',D:'#ffd426',F:'#c41e3a',B:'#ff5800',L:'#0051ba',R:'#009e60'};
  const col=faceColors[face]||'#c43e1c';
  if(is180) return `<svg class="arrow-svg" viewBox="0 0 60 60"><path d="M30 8 A22 22 0 1 1 8 30" fill="none" stroke="${col}" stroke-width="4.5" stroke-linecap="round"/><polygon points="8,30 2,22 14,22" fill="${col}"/><path d="M30 8 A22 22 0 0 0 52 30" fill="none" stroke="${col}" stroke-width="4.5" stroke-linecap="round" stroke-dasharray="4 3"/><polygon points="52,30 46,22 58,22" fill="${col}"/></svg>`;
  if(isPrime) return `<svg class="arrow-svg" viewBox="0 0 60 60"><path d="M42 10 A22 22 0 1 0 10 35" fill="none" stroke="${col}" stroke-width="4.5" stroke-linecap="round"/><polygon points="10,35 4,26 16,27" fill="${col}"/></svg>`;
  return `<svg class="arrow-svg" viewBox="0 0 60 60"><path d="M18 10 A22 22 0 1 1 50 35" fill="none" stroke="${col}" stroke-width="4.5" stroke-linecap="round"/><polygon points="50,35 56,26 44,27" fill="${col}"/></svg>`;
}

function showArrow(notation){
  const desc=MOVE_DESC[notation]||notation;
  arrowBox.innerHTML=`${getArrowSVG(notation)}<div><div class="arrow-label">${notation}</div><div class="arrow-desc">${desc}</div></div>`;
}
function clearArrow(){ arrowBox.innerHTML=''; }

const moveDisplay = document.getElementById('moveDisplay');
function updateMoveDisplay(moves, idx){
  if(!moves.length){moveDisplay.innerHTML='';return;}
  let html='';
  const win=5, start=Math.max(0,idx-win), end=Math.min(moves.length,idx+win+1);
  if(start>0) html+='<span class="mv done">…</span>';
  for(let i=start;i<end;i++){
    if(i<idx) html+=`<span class="mv done">${moves[i]}</span>`;
    else if(i===idx) html+=`<span class="mv current">${moves[i]}</span>`;
    else html+=`<span class="mv future">${moves[i]}</span>`;
  }
  if(end<moves.length) html+='<span class="mv future">…</span>';
  moveDisplay.innerHTML=html;
}

let scrambleMoves=[], solveMoves=[], currentSolveIdx=0, solving=false;

function invertMove(m){
  if(m.includes('2'))return m;
  if(m.includes("'"))return m[0];
  return m+"'";
}

async function doScramble(){
  if(isAnimating||solving)return;
  buildCube(); scrambleMoves=[]; solveMoves=[]; currentSolveIdx=0;
  const faces=['U','D','F','B','L','R'], mods=['', "'", '2'];
  let last=''; const numMoves=18+Math.floor(Math.random()*8);
  statusText.textContent='Scrambling...'; scrambleBtn.disabled=true;
  for(let i=0;i<numMoves;i++){
    let f; do{f=faces[Math.floor(Math.random()*6)]}while(f===last); last=f;
    const mv=f+mods[Math.floor(Math.random()*3)];
    scrambleMoves.push(mv); showArrow(mv);
    await executeMove(mv, Math.max(80, speedMs*0.3));
  }
  solveMoves=scrambleMoves.map(invertMove).reverse();
  moveTotalEl.textContent=solveMoves.length; moveIdxEl.textContent='0';
  statusText.textContent='Scrambled'; clearArrow();
  updateMoveDisplay(solveMoves,-1); scrambleBtn.disabled=false; updateBtnState();
}

async function animateSolve(){
  if(solving||isAnimating)return;
  solving=true; scrambleBtn.disabled=true; solveBtn.disabled=true; stepBtn.disabled=true;
  statusText.textContent='Solving...';
  while(currentSolveIdx<solveMoves.length && solving){
    const mv=solveMoves[currentSolveIdx];
    updateMoveDisplay(solveMoves,currentSolveIdx); showArrow(mv);
    await executeMove(mv,speedMs); currentSolveIdx++;
    moveIdxEl.textContent=currentSolveIdx;
    await new Promise(r=>setTimeout(r,speedMs*0.15));
  }
  if(currentSolveIdx>=solveMoves.length){
    statusText.textContent='Solved!'; clearArrow();
    moveDisplay.innerHTML='<span class="mv current">✓ Done</span>';
  }
  solving=false; scrambleBtn.disabled=false; updateBtnState();
}

async function stepOnce(){
  if(isAnimating||currentSolveIdx>=solveMoves.length)return;
  const mv=solveMoves[currentSolveIdx];
  updateMoveDisplay(solveMoves,currentSolveIdx); showArrow(mv);
  stepBtn.disabled=true; stepBackBtn.disabled=true;
  await executeMove(mv,speedMs); currentSolveIdx++;
  moveIdxEl.textContent=currentSolveIdx;
  statusText.textContent=`Solving (${currentSolveIdx}/${solveMoves.length})`;
  if(currentSolveIdx>=solveMoves.length){
    statusText.textContent='Solved!'; setTimeout(clearArrow,speedMs);
    moveDisplay.innerHTML='<span class="mv current">✓ Done</span>';
  }
  updateBtnState();
}

async function stepBack(){
  if(isAnimating||currentSolveIdx<=0)return;
  currentSolveIdx--;
  const mv=solveMoves[currentSolveIdx], undoMv=invertMove(mv);
  updateMoveDisplay(solveMoves,currentSolveIdx); showArrow(undoMv);
  stepBtn.disabled=true; stepBackBtn.disabled=true;
  await executeMove(undoMv,speedMs);
  moveIdxEl.textContent=currentSolveIdx;
  statusText.textContent=`Solving (${currentSolveIdx}/${solveMoves.length})`;
  updateBtnState();
}

function doReset(){
  solving=false; isAnimating=false;
  scrambleMoves=[]; solveMoves=[]; currentSolveIdx=0;
  buildCube(); statusText.textContent='Ready';
  moveIdxEl.textContent='0'; moveTotalEl.textContent='0';
  moveDisplay.innerHTML=''; clearArrow(); updateBtnState();
}

function updateBtnState(){
  const fwd=solveMoves.length>0&&currentSolveIdx<solveMoves.length;
  const back=solveMoves.length>0&&currentSolveIdx>0;
  solveBtn.disabled=!fwd||solving||isAnimating;
  stepBtn.disabled=!fwd||solving||isAnimating;
  stepBackBtn.disabled=!back||solving||isAnimating;
}

let speedMs=800;
const speedSlider=document.getElementById('speedSlider');
const speedValEl=document.getElementById('speedVal');
const statusText=document.getElementById('statusText');
const moveIdxEl=document.getElementById('moveIdx');
const moveTotalEl=document.getElementById('moveTotal');
const stepBackBtn=document.getElementById('stepBackBtn');
const scrambleBtn=document.getElementById('scrambleBtn');

function updateSpeed(){
  const v=parseInt(speedSlider.value);
  speedMs=Math.round(1500-(v-1)*150);
  speedValEl.textContent=(speedMs/1000).toFixed(1)+'s';
}
speedSlider.addEventListener('input',updateSpeed);

scrambleBtn.addEventListener('click',doScramble);
document.getElementById('solveBtn').addEventListener('click',animateSolve);
document.getElementById('stepBtn').addEventListener('click',stepOnce);
stepBackBtn.addEventListener('click',stepBack);
document.getElementById('resetBtn').addEventListener('click',doReset);

buildCube(); updateCamera(); updateSpeed(); renderLoop();
requestAnimationFrame(()=>{ resize(); requestAnimationFrame(resize); });
</script>
</body>
</html>
