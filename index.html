<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Rubik's Cube Solver</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@400;500&family=Sora:wght@300;400;600;800&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
:root {
  --bg: #f4f1eb;
  --surface: #fff;
  --border: #e0dbd2;
  --text: #1a1714;
  --text-dim: #8a857c;
  --accent: #c43e1c;
  --accent2: #1a6b4a;
}
html{font-size:16px}
body{
  background:var(--bg);color:var(--text);
  font-family:'Sora',sans-serif;
  height:100vh;height:100dvh;
  overflow:hidden;user-select:none;-webkit-user-select:none;
}
body::before{
  content:'';position:fixed;inset:0;
  background-image:url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23000' fill-opacity='0.02'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
  pointer-events:none;z-index:0;
}
.layout{
  display:flex;flex-direction:column;
  height:100vh;height:100dvh;
  position:relative;z-index:1;overflow:hidden;
}
.header{padding:0.5rem 1rem 0.15rem;text-align:center;flex-shrink:0}
.header h1{
  font-family:'DM Mono',monospace;
  font-size:clamp(1rem,2.8vw,1.6rem);
  font-weight:500;letter-spacing:-0.03em;
}
.header h1 span{color:var(--accent)}
.info-bar{
  display:flex;align-items:center;justify-content:center;
  gap:0.8rem;padding:0.15rem 0.5rem;flex-shrink:0;flex-wrap:wrap;
}
.stat{font-family:'DM Mono',monospace;font-size:0.6rem;color:var(--text-dim)}
.stat span{color:var(--accent);font-weight:500}
.arrow-inline{display:flex;align-items:center;gap:0.25rem}
.arrow-inline .arrow-svg{width:26px;height:26px}
.arrow-inline .arrow-label{font-family:'DM Mono',monospace;font-size:0.75rem;font-weight:600;color:var(--accent)}
.arrow-inline .arrow-desc{font-family:'Sora',sans-serif;font-size:0.55rem;color:var(--text-dim)}
.move-display{
  font-family:'DM Mono',monospace;font-size:0.65rem;
  color:var(--text-dim);text-align:center;
  padding:0.05rem 0.5rem;flex-shrink:0;
  display:flex;align-items:center;justify-content:center;gap:0.15rem;
  flex-wrap:wrap;min-height:1.3em;
}
.mv{display:inline-flex;align-items:center;justify-content:center;padding:0.1rem 0.25rem;border-radius:3px;font-size:0.55rem;transition:all 0.2s}
.mv.done{background:#e8e6e0;color:var(--text-dim);opacity:0.5}
.mv.current{background:var(--accent);color:#fff;font-weight:600;font-size:0.65rem;box-shadow:0 1px 5px rgba(196,62,28,0.3);transform:scale(1.1)}
.mv.future{background:#eae7e0;color:var(--text-dim)}

/* Middle: canvas + face buttons */
.cube-area{
  flex:1;min-height:0;display:flex;align-items:stretch;
  position:relative;
}
.face-btns{
  display:flex;flex-direction:column;
  justify-content:center;gap:0.25rem;
  padding:0.3rem;flex-shrink:0;
  width:clamp(42px, 8vw, 56px);
}
.face-btn{
  font-family:'DM Mono',monospace;
  font-size:0.55rem;font-weight:500;
  border:1.5px solid var(--border);
  background:var(--surface);color:var(--text);
  border-radius:5px;cursor:pointer;
  padding:0.25rem 0.1rem;
  text-align:center;line-height:1.15;
  transition:all 0.15s;
  -webkit-tap-highlight-color:transparent;
  touch-action:manipulation;
}
.face-btn:hover{border-color:var(--accent);color:var(--accent);background:#fdf8f5}
.face-btn:active{transform:scale(0.93);background:#f5ebe4}
.face-btn:disabled{opacity:0.25;cursor:not-allowed;transform:none}
.face-btn .dir{font-size:0.7rem;display:block;line-height:1}
.face-btn .lbl{font-size:0.48rem;color:var(--text-dim);display:block;margin-top:1px}

/* Color-coded borders */
.face-btn[data-face="U"]{border-left:3px solid #aaa}
.face-btn[data-face="D"]{border-left:3px solid #ffd426}
.face-btn[data-face="F"]{border-left:3px solid #c41e3a}
.face-btn[data-face="B"]{border-left:3px solid #ff5800}
.face-btn[data-face="R"]{border-left:3px solid #009e60}
.face-btn[data-face="L"]{border-left:3px solid #0051ba}

#cubeCanvas{display:block;cursor:grab;flex:1;min-width:0;height:100%}
#cubeCanvas:active{cursor:grabbing}

/* Mode toggle */
.mode-toggle{
  display:flex;justify-content:center;gap:0;
  padding:0.2rem 0.5rem 0.1rem;flex-shrink:0;
}
.mode-btn{
  font-family:'DM Mono',monospace;font-size:0.58rem;
  padding:0.3rem 0.8rem;border:1.5px solid var(--border);
  background:var(--surface);color:var(--text-dim);
  cursor:pointer;transition:all 0.15s;
  -webkit-tap-highlight-color:transparent;
}
.mode-btn:first-child{border-radius:5px 0 0 5px;border-right:none}
.mode-btn:last-child{border-radius:0 5px 5px 0}
.mode-btn.active{background:var(--accent);color:#fff;border-color:var(--accent);font-weight:500}

.controls{
  display:flex;flex-wrap:wrap;justify-content:center;
  align-items:center;gap:0.4rem;
  padding:0.3rem 0.5rem;flex-shrink:0;
  padding-bottom:max(0.3rem, env(safe-area-inset-bottom));
}
.ctrl-group{display:flex;flex-direction:column;align-items:center;gap:0.1rem}
.ctrl-group label{font-family:'DM Mono',monospace;font-size:0.48rem;color:var(--text-dim);text-transform:uppercase;letter-spacing:0.12em}
.btn{
  font-family:'DM Mono',monospace;font-size:0.62rem;letter-spacing:0.03em;
  padding:0.4rem 0.65rem;border:1.5px solid var(--border);
  background:var(--surface);color:var(--text);border-radius:6px;
  cursor:pointer;transition:all 0.2s;
  -webkit-tap-highlight-color:transparent;touch-action:manipulation;
}
.btn:hover{border-color:var(--accent);color:var(--accent)}
.btn:active{transform:scale(0.96)}
.btn:disabled{opacity:0.3;cursor:not-allowed;transform:none}
.btn--accent{background:var(--accent);color:#fff;border-color:var(--accent)}
.btn--accent:hover{background:#a83518;border-color:#a83518;color:#fff}
.btn--green{background:var(--accent2);color:#fff;border-color:var(--accent2)}
.btn--green:hover{background:#145a3e;border-color:#145a3e;color:#fff}
.slider-wrap{display:flex;align-items:center;gap:0.3rem}
.speed-slider{-webkit-appearance:none;appearance:none;width:80px;height:3px;background:var(--border);border-radius:2px;outline:none}
.speed-slider::-webkit-slider-thumb{-webkit-appearance:none;width:20px;height:20px;border-radius:50%;background:var(--accent);cursor:pointer;box-shadow:0 1px 4px rgba(196,62,28,0.3)}
.speed-val{font-family:'DM Mono',monospace;font-size:0.58rem;color:var(--accent);min-width:3.5ch;text-align:center}
.step-row{display:flex;gap:0.25rem}

/* Move counter for manual mode */
.manual-count{
  font-family:'DM Mono',monospace;font-size:0.6rem;color:var(--text-dim);
}
.manual-count span{color:var(--accent);font-weight:500}

/* Hide controls based on mode */
.auto-only{display:flex}
.manual-only{display:none}
body.manual-mode .auto-only{display:none}
body.manual-mode .manual-only{display:flex}

/* Difficulty buttons */
.diff-row{display:flex;gap:0.2rem}
.diff-btn{
  font-family:'DM Mono',monospace;font-size:0.52rem;letter-spacing:0.02em;
  padding:0.3rem 0.45rem;border:1.5px solid var(--border);
  background:var(--surface);color:var(--text);border-radius:5px;
  cursor:pointer;transition:all 0.15s;
  -webkit-tap-highlight-color:transparent;touch-action:manipulation;
}
.diff-btn:hover{border-color:var(--accent);color:var(--accent)}
.diff-btn:active{transform:scale(0.96)}
.diff-btn:disabled{opacity:0.3;cursor:not-allowed;transform:none}
.diff-btn.easy{border-bottom:2.5px solid #4CAF50}
.diff-btn.moderate{border-bottom:2.5px solid #FF9800}
.diff-btn.hard{border-bottom:2.5px solid #f44336}

/* Hint button */
.btn--hint{background:#5c6bc0;color:#fff;border-color:#5c6bc0}
.btn--hint:hover{background:#3f51b5;border-color:#3f51b5;color:#fff}

/* Hint display */
.hint-display{
  font-family:'DM Mono',monospace;font-size:0.6rem;
  color:var(--text-dim);text-align:center;
  padding:0.05rem 0.5rem;flex-shrink:0;
  display:none;align-items:center;justify-content:center;gap:0.3rem;
  min-height:1.3em;
}
body.manual-mode .hint-display{display:flex}
.hint-display .hint-move{
  background:#5c6bc0;color:#fff;padding:0.15rem 0.4rem;
  border-radius:4px;font-weight:600;font-size:0.7rem;
}
.hint-display .hint-remaining{color:var(--text-dim);font-size:0.5rem}
.hint-display .arrow-svg{width:22px;height:22px;vertical-align:middle}

/* Confetti overlay */
.confetti-overlay{
  position:fixed;inset:0;pointer-events:none;z-index:1000;
}
.congrats-msg{
  position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(0);
  font-family:'Sora',sans-serif;font-size:clamp(1.5rem,5vw,3rem);font-weight:800;
  color:var(--accent);text-align:center;
  text-shadow:0 2px 15px rgba(196,62,28,0.3);
  z-index:1001;pointer-events:none;
  animation:congratsPop 0.6s ease-out forwards;
}
.congrats-msg .sub{
  display:block;font-size:0.4em;font-weight:400;color:var(--text-dim);margin-top:0.3em;
}
@keyframes congratsPop{
  0%{transform:translate(-50%,-50%) scale(0);opacity:0}
  50%{transform:translate(-50%,-50%) scale(1.15);opacity:1}
  100%{transform:translate(-50%,-50%) scale(1);opacity:1}
}
@keyframes congratsFade{
  0%{opacity:1}
  100%{opacity:0;transform:translate(-50%,-50%) scale(0.8)}
}

@media(max-width:480px){
  .header{padding:0.35rem 0.5rem 0.1rem}
  .controls{gap:0.25rem;padding:0.25rem 0.3rem}
  .btn{padding:0.35rem 0.5rem;font-size:0.56rem}
  .speed-slider{width:60px}
  .face-btns{width:38px;gap:0.2rem;padding:0.2rem}
  .face-btn{font-size:0.5rem;padding:0.2rem 0.05rem}
  .face-btn .dir{font-size:0.6rem}
  .face-btn .lbl{font-size:0.42rem}
  .mode-btn{font-size:0.52rem;padding:0.25rem 0.6rem}
  .info-bar{gap:0.3rem}
}
@media(max-height:500px){
  .header h1{font-size:0.9rem}
  .header{padding:0.15rem 0.5rem 0.05rem}
  .info-bar{padding:0.08rem}
  .move-display{min-height:0.8em;padding:0.02rem}
  .controls{padding:0.15rem}
  .face-btns{gap:0.15rem}
}
</style>
</head>
<body>
<div class="layout">
  <div class="header">
    <h1>Rubik's <span>Cube</span></h1>
  </div>
  <div class="info-bar">
    <div class="stat">Status: <span id="statusText">Ready</span></div>
    <div class="stat auto-only">Moves: <span id="moveIdx">0</span>/<span id="moveTotal">0</span></div>
    <div class="stat manual-only manual-count">Moves: <span id="manualCount">0</span></div>
    <div class="arrow-inline" id="arrowBox"></div>
  </div>
  <div class="move-display auto-only" id="moveDisplay"></div>
  <div class="hint-display" id="hintDisplay"></div>

  <div class="cube-area">
    <div class="face-btns manual-only" id="leftBtns">
      <button class="face-btn" data-face="U" data-move="U"><span class="dir">↻</span><span class="lbl">U</span></button>
      <button class="face-btn" data-face="U" data-move="U'"><span class="dir">↺</span><span class="lbl">U'</span></button>
      <button class="face-btn" data-face="F" data-move="F"><span class="dir">↻</span><span class="lbl">F</span></button>
      <button class="face-btn" data-face="F" data-move="F'"><span class="dir">↺</span><span class="lbl">F'</span></button>
      <button class="face-btn" data-face="L" data-move="L"><span class="dir">↻</span><span class="lbl">L</span></button>
      <button class="face-btn" data-face="L" data-move="L'"><span class="dir">↺</span><span class="lbl">L'</span></button>
    </div>
    <canvas id="cubeCanvas"></canvas>
    <div class="face-btns manual-only" id="rightBtns">
      <button class="face-btn" data-face="D" data-move="D"><span class="dir">↻</span><span class="lbl">D</span></button>
      <button class="face-btn" data-face="D" data-move="D'"><span class="dir">↺</span><span class="lbl">D'</span></button>
      <button class="face-btn" data-face="B" data-move="B"><span class="dir">↻</span><span class="lbl">B</span></button>
      <button class="face-btn" data-face="B" data-move="B'"><span class="dir">↺</span><span class="lbl">B'</span></button>
      <button class="face-btn" data-face="R" data-move="R"><span class="dir">↻</span><span class="lbl">R</span></button>
      <button class="face-btn" data-face="R" data-move="R'"><span class="dir">↺</span><span class="lbl">R'</span></button>
    </div>
  </div>

  <div class="mode-toggle">
    <button class="mode-btn active" id="modeAuto">Auto</button>
    <button class="mode-btn" id="modeManual">Manual</button>
  </div>

  <div class="controls">
    <div class="ctrl-group">
      <label>Speed</label>
      <div class="slider-wrap">
        <input type="range" class="speed-slider" id="speedSlider" min="1" max="10" value="4">
        <div class="speed-val" id="speedVal">0.8s</div>
      </div>
    </div>
    <button class="btn auto-only" id="scrambleBtn">Scramble</button>
    <div class="diff-row manual-only">
      <button class="diff-btn easy" id="diffEasy">Easy</button>
      <button class="diff-btn moderate" id="diffModerate">Medium</button>
      <button class="diff-btn hard" id="diffHard">Hard</button>
    </div>
    <button class="btn btn--hint manual-only" id="hintBtn">Hint</button>
    <button class="btn btn--accent auto-only" id="solveBtn" disabled>Solve</button>
    <div class="step-row auto-only">
      <button class="btn" id="stepBackBtn" disabled>◀</button>
      <button class="btn" id="stepBtn" disabled>▶</button>
    </div>
    <button class="btn btn--green" id="resetBtn">Reset</button>
  </div>
</div>

<script>
const COLORS = {
  W: 0xffffff, Y: 0xffd426, R: 0xc41e3a,
  O: 0xff5800, B: 0x0051ba, G: 0x009e60, X: 0x1a1714
};
const canvas = document.getElementById('cubeCanvas');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setClearColor(0x000000, 0);
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
camera.position.set(5, 4, 6); camera.lookAt(0,0,0);
scene.add(new THREE.AmbientLight(0xffffff, 0.65));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
dirLight.position.set(5,8,6); scene.add(dirLight);

const GAP = 0.06, CUBIE_SIZE = 0.874, SPACING = 0.95 + GAP;
const cubies = [];
const cubieMeshes = new THREE.Group();
scene.add(cubieMeshes);

function makeCubieMaterials(ix,iy,iz){
  return [
    new THREE.MeshStandardMaterial({color:ix===1?COLORS.G:COLORS.X}),
    new THREE.MeshStandardMaterial({color:ix===-1?COLORS.B:COLORS.X}),
    new THREE.MeshStandardMaterial({color:iy===1?COLORS.W:COLORS.X}),
    new THREE.MeshStandardMaterial({color:iy===-1?COLORS.Y:COLORS.X}),
    new THREE.MeshStandardMaterial({color:iz===1?COLORS.R:COLORS.X}),
    new THREE.MeshStandardMaterial({color:iz===-1?COLORS.O:COLORS.X}),
  ];
}
function buildCube(){
  while(cubieMeshes.children.length) cubieMeshes.remove(cubieMeshes.children[0]);
  cubies.length=0;
  const geo=new THREE.BoxGeometry(CUBIE_SIZE,CUBIE_SIZE,CUBIE_SIZE);
  for(let x=-1;x<=1;x++) for(let y=-1;y<=1;y++) for(let z=-1;z<=1;z++){
    const mesh=new THREE.Mesh(geo,makeCubieMaterials(x,y,z));
    mesh.position.set(x*SPACING,y*SPACING,z*SPACING);
    cubieMeshes.add(mesh); cubies.push({mesh,ix:x,iy:y,iz:z});
  }
}

let isAnimating=false;

// Pre-compute the 24 valid cube orientations
const VALID_QUATS=(function(){
  const qs=[];const r=Math.PI/2;
  for(let ax=0;ax<4;ax++) for(let ay=0;ay<4;ay++) for(let az=0;az<4;az++){
    const q=new THREE.Quaternion().setFromEuler(new THREE.Euler(ax*r,ay*r,az*r));
    let dup=false;
    for(const existing of qs){
      if(Math.abs(q.dot(existing))>0.999){dup=true;break;}
    }
    if(!dup) qs.push(q);
  }
  return qs;
})();

function snapQuaternion(q){
  let best=VALID_QUATS[0],bestDot=Math.abs(q.dot(VALID_QUATS[0]));
  for(let i=1;i<VALID_QUATS.length;i++){
    const d=Math.abs(q.dot(VALID_QUATS[i]));
    if(d>bestDot){bestDot=d;best=VALID_QUATS[i];}
  }
  q.copy(best);
}

function getLayerCubies(axis,layer){
  return cubies.filter(c=>axis==='x'?c.ix===layer:axis==='y'?c.iy===layer:c.iz===layer);
}

// No reparenting approach: cubies always stay in cubieMeshes.
// During animation we manually set each cubie's position/quaternion per frame.
// At the end we snap to exact grid values.
function animateLayerRotation(axis,layer,angleDeg,duration){
  return new Promise(resolve=>{
    if(isAnimating){resolve();return;}
    isAnimating=true;
    const affected=getLayerCubies(axis,layer);
    const axisVec=axis==='x'?new THREE.Vector3(1,0,0):axis==='y'?new THREE.Vector3(0,1,0):new THREE.Vector3(0,0,1);
    const angleRad=THREE.MathUtils.degToRad(angleDeg);
    const finalQ=new THREE.Quaternion().setFromAxisAngle(axisVec,angleRad);

    // Save starting state
    const starts=affected.map(c=>({pos:c.mesh.position.clone(),quat:c.mesh.quaternion.clone()}));

    const startTime=performance.now();
    function tick(){
      const t=Math.min((performance.now()-startTime)/duration,1);
      const ease=1-Math.pow(1-t,3);
      const partialQ=new THREE.Quaternion().setFromAxisAngle(axisVec,angleRad*ease);

      // Apply partial rotation to each cubie individually (no reparenting)
      affected.forEach((c,i)=>{
        c.mesh.position.copy(starts[i].pos).applyQuaternion(partialQ);
        c.mesh.quaternion.copy(partialQ).multiply(starts[i].quat);
      });

      if(t<1){requestAnimationFrame(tick);return;}

      // Animation done — snap to exact values using the clean final quaternion
      affected.forEach((c,i)=>{
        const newPos=starts[i].pos.clone().applyQuaternion(finalQ);
        c.ix=Math.round(newPos.x/SPACING);
        c.iy=Math.round(newPos.y/SPACING);
        c.iz=Math.round(newPos.z/SPACING);
        c.mesh.position.set(c.ix*SPACING,c.iy*SPACING,c.iz*SPACING);
        c.mesh.quaternion.copy(finalQ).multiply(starts[i].quat);
        snapQuaternion(c.mesh.quaternion);
      });

      isAnimating=false;resolve();
    }
    requestAnimationFrame(tick);
  });
}

const MOVE_MAP={
  'U':{axis:'y',layer:1,angle:-90},"U'":{axis:'y',layer:1,angle:90},'U2':{axis:'y',layer:1,angle:-180},
  'D':{axis:'y',layer:-1,angle:90},"D'":{axis:'y',layer:-1,angle:-90},'D2':{axis:'y',layer:-1,angle:180},
  'F':{axis:'z',layer:1,angle:-90},"F'":{axis:'z',layer:1,angle:90},'F2':{axis:'z',layer:1,angle:-180},
  'B':{axis:'z',layer:-1,angle:90},"B'":{axis:'z',layer:-1,angle:-90},'B2':{axis:'z',layer:-1,angle:180},
  'R':{axis:'x',layer:1,angle:-90},"R'":{axis:'x',layer:1,angle:90},'R2':{axis:'x',layer:1,angle:-180},
  'L':{axis:'x',layer:-1,angle:90},"L'":{axis:'x',layer:-1,angle:-90},'L2':{axis:'x',layer:-1,angle:180},
};
async function executeMove(notation,duration){
  const m=MOVE_MAP[notation];if(!m)return;
  await animateLayerRotation(m.axis,m.layer,m.angle,duration);
}

// Camera orbit
let orbiting=false,orbX,orbY;
let cameraTheta=Math.PI/4,cameraPhi=Math.PI/6;
function updateCamera(){
  camera.position.x=currentCameraRadius*Math.cos(cameraPhi)*Math.sin(cameraTheta);
  camera.position.y=currentCameraRadius*Math.sin(cameraPhi);
  camera.position.z=currentCameraRadius*Math.cos(cameraPhi)*Math.cos(cameraTheta);
  camera.lookAt(0,0,0);
}
canvas.addEventListener('mousedown',e=>{orbiting=true;orbX=e.clientX;orbY=e.clientY});
window.addEventListener('mousemove',e=>{
  if(!orbiting)return;
  cameraTheta-=(e.clientX-orbX)*0.008;cameraPhi+=(e.clientY-orbY)*0.008;
  cameraPhi=Math.max(-Math.PI/3,Math.min(Math.PI/3,cameraPhi));
  orbX=e.clientX;orbY=e.clientY;updateCamera();
});
window.addEventListener('mouseup',()=>{orbiting=false});
canvas.addEventListener('touchstart',e=>{
  if(e.touches.length===1){orbiting=true;orbX=e.touches[0].clientX;orbY=e.touches[0].clientY}
},{passive:true});
window.addEventListener('touchmove',e=>{
  if(!orbiting||e.touches.length!==1)return;
  cameraTheta-=(e.touches[0].clientX-orbX)*0.008;
  cameraPhi+=(e.touches[0].clientY-orbY)*0.008;
  cameraPhi=Math.max(-Math.PI/3,Math.min(Math.PI/3,cameraPhi));
  orbX=e.touches[0].clientX;orbY=e.touches[0].clientY;updateCamera();
},{passive:true});
window.addEventListener('touchend',()=>{orbiting=false});

function resize(){
  const rect=canvas.getBoundingClientRect();
  const w=rect.width,h=rect.height;
  if(w===0||h===0)return;
  const dpr=Math.min(window.devicePixelRatio,2);
  canvas.width=w*dpr;canvas.height=h*dpr;
  renderer.setSize(w,h);camera.aspect=w/h;camera.updateProjectionMatrix();
}
window.addEventListener('resize',resize);
function renderLoop(){requestAnimationFrame(renderLoop);renderer.render(scene,camera);}

// Arrow
const arrowBox=document.getElementById('arrowBox');
const MOVE_DESC={
  'U':'Top CW',"U'":'Top CCW','U2':'Top 180°',
  'D':'Bottom CW',"D'":'Bottom CCW','D2':'Bottom 180°',
  'F':'Front CW',"F'":'Front CCW','F2':'Front 180°',
  'B':'Back CW',"B'":'Back CCW','B2':'Back 180°',
  'R':'Right CW',"R'":'Right CCW','R2':'Right 180°',
  'L':'Left CW',"L'":'Left CCW','L2':'Left 180°',
};
function getArrowSVG(notation){
  const is180=notation.includes('2'),isPrime=notation.includes("'"),face=notation[0];
  const faceColors={U:'#888',D:'#ffd426',F:'#c41e3a',B:'#ff5800',L:'#0051ba',R:'#009e60'};
  const col=faceColors[face]||'#c43e1c';
  if(is180) return `<svg class="arrow-svg" viewBox="0 0 60 60"><path d="M30 8 A22 22 0 1 1 8 30" fill="none" stroke="${col}" stroke-width="4.5" stroke-linecap="round"/><polygon points="8,30 2,22 14,22" fill="${col}"/><path d="M30 8 A22 22 0 0 0 52 30" fill="none" stroke="${col}" stroke-width="4.5" stroke-linecap="round" stroke-dasharray="4 3"/><polygon points="52,30 46,22 58,22" fill="${col}"/></svg>`;
  if(isPrime) return `<svg class="arrow-svg" viewBox="0 0 60 60"><path d="M42 10 A22 22 0 1 0 10 35" fill="none" stroke="${col}" stroke-width="4.5" stroke-linecap="round"/><polygon points="10,35 4,26 16,27" fill="${col}"/></svg>`;
  return `<svg class="arrow-svg" viewBox="0 0 60 60"><path d="M18 10 A22 22 0 1 1 50 35" fill="none" stroke="${col}" stroke-width="4.5" stroke-linecap="round"/><polygon points="50,35 56,26 44,27" fill="${col}"/></svg>`;
}
function showArrow(notation){
  const desc=MOVE_DESC[notation]||notation;
  arrowBox.innerHTML=`${getArrowSVG(notation)}<div><div class="arrow-label">${notation}</div><div class="arrow-desc">${desc}</div></div>`;
}
function clearArrow(){arrowBox.innerHTML='';}

// Move display
const moveDisplay=document.getElementById('moveDisplay');
function updateMoveDisplay(moves,idx){
  if(!moves.length){moveDisplay.innerHTML='';return;}
  let html='';
  const win=5,start=Math.max(0,idx-win),end=Math.min(moves.length,idx+win+1);
  if(start>0) html+='<span class="mv done">…</span>';
  for(let i=start;i<end;i++){
    if(i<idx) html+=`<span class="mv done">${moves[i]}</span>`;
    else if(i===idx) html+=`<span class="mv current">${moves[i]}</span>`;
    else html+=`<span class="mv future">${moves[i]}</span>`;
  }
  if(end<moves.length) html+='<span class="mv future">…</span>';
  moveDisplay.innerHTML=html;
}

// State
let scrambleMoves=[],solveMoves=[],currentSolveIdx=0,solving=false;
let manualMode=false, manualMoveCount=0;
const manualCountEl=document.getElementById('manualCount');

function invertMove(m){
  if(m.includes('2'))return m;
  if(m.includes("'"))return m[0];
  return m+"'";
}

// Scramble
async function doScramble(){
  if(isAnimating||solving)return;
  buildCube();scrambleMoves=[];solveMoves=[];currentSolveIdx=0;manualMoveCount=0;
  manualCountEl.textContent='0';
  const faces=['U','D','F','B','L','R'],mods=['', "'", '2'];
  let last='';const numMoves=18+Math.floor(Math.random()*8);
  statusText.textContent='Scrambling...';scrambleBtn.disabled=true;
  setFaceBtnsEnabled(false);
  for(let i=0;i<numMoves;i++){
    let f;do{f=faces[Math.floor(Math.random()*6)]}while(f===last);last=f;
    const mv=f+mods[Math.floor(Math.random()*3)];
    scrambleMoves.push(mv);showArrow(mv);
    await executeMove(mv,Math.max(80,speedMs*0.3));
  }
  solveMoves=scrambleMoves.map(invertMove).reverse();
  moveTotalEl.textContent=solveMoves.length;moveIdxEl.textContent='0';
  statusText.textContent='Scrambled';clearArrow();
  updateMoveDisplay(solveMoves,-1);scrambleBtn.disabled=false;
  setFaceBtnsEnabled(true);
  updateBtnState();
}

// Manual mode scramble with difficulty
let manualSolution=[];  // solution moves (reverse of scramble)
let manualHintIdx=0;    // tracks which hint to show next
const hintDisplay=document.getElementById('hintDisplay');

async function doManualScramble(numMoves){
  if(isAnimating||solving)return;
  buildCube();scrambleMoves=[];manualSolution=[];manualHintIdx=0;
  manualMoveCount=0;manualCountEl.textContent='0';
  hintDisplay.innerHTML='';
  const faces=['U','D','F','B','L','R'],mods=['', "'"];
  let last='';
  statusText.textContent='Scrambling...';
  setDiffBtnsEnabled(false);setFaceBtnsEnabled(false);
  document.getElementById('hintBtn').disabled=true;
  for(let i=0;i<numMoves;i++){
    let f;do{f=faces[Math.floor(Math.random()*6)]}while(f===last);last=f;
    const mv=f+mods[Math.floor(Math.random()*2)];
    scrambleMoves.push(mv);showArrow(mv);
    await executeMove(mv,Math.max(80,speedMs*0.3));
  }
  manualSolution=scrambleMoves.map(invertMove).reverse();
  manualHintIdx=0;
  statusText.textContent='Scrambled ('+numMoves+' moves)';clearArrow();
  setDiffBtnsEnabled(true);setFaceBtnsEnabled(true);
  document.getElementById('hintBtn').disabled=false;
}

function setDiffBtnsEnabled(enabled){
  document.getElementById('diffEasy').disabled=!enabled;
  document.getElementById('diffModerate').disabled=!enabled;
  document.getElementById('diffHard').disabled=!enabled;
}

// Hint system — track user moves and compare to solution
function showHint(){
  if(manualSolution.length===0){
    hintDisplay.innerHTML='<span style="color:var(--text-dim)">Scramble first!</span>';
    return;
  }
  if(manualHintIdx>=manualSolution.length){
    hintDisplay.innerHTML='<span style="color:var(--accent2)">Already solved!</span>';
    return;
  }
  const nextMove=manualSolution[manualHintIdx];
  const remaining=manualSolution.length-manualHintIdx;
  hintDisplay.innerHTML=
    'Next: <span class="hint-move">'+nextMove+'</span> '+
    getArrowSVG(nextMove)+
    ' <span class="hint-remaining">('+remaining+' left)</span>';
}

// When user makes a manual move, check if it matches solution
function updateHintTracking(notation){
  if(manualSolution.length===0||manualHintIdx>=manualSolution.length)return;
  if(notation===manualSolution[manualHintIdx]){
    // Correct move — advance hint
    manualHintIdx++;
  }else{
    // Wrong move — append its inverse to the solution
    manualSolution.splice(manualHintIdx,0,invertMove(notation));
    manualHintIdx++;
  }
  // Clear hint display after move
  hintDisplay.innerHTML='';
}

// Auto solve
async function animateSolve(){
  if(solving||isAnimating)return;
  solving=true;scrambleBtn.disabled=true;solveBtn.disabled=true;stepBtn.disabled=true;
  statusText.textContent='Solving...';
  while(currentSolveIdx<solveMoves.length&&solving){
    const mv=solveMoves[currentSolveIdx];
    updateMoveDisplay(solveMoves,currentSolveIdx);showArrow(mv);
    await executeMove(mv,speedMs);currentSolveIdx++;
    moveIdxEl.textContent=currentSolveIdx;
    await new Promise(r=>setTimeout(r,speedMs*0.15));
  }
  if(currentSolveIdx>=solveMoves.length){
    statusText.textContent='Solved!';clearArrow();
    moveDisplay.innerHTML='<span class="mv current">✓ Done</span>';
  }
  solving=false;scrambleBtn.disabled=false;updateBtnState();
}

async function stepOnce(){
  if(isAnimating||currentSolveIdx>=solveMoves.length)return;
  const mv=solveMoves[currentSolveIdx];
  updateMoveDisplay(solveMoves,currentSolveIdx);showArrow(mv);
  stepBtn.disabled=true;stepBackBtn.disabled=true;
  await executeMove(mv,speedMs);currentSolveIdx++;
  moveIdxEl.textContent=currentSolveIdx;
  statusText.textContent=`Solving (${currentSolveIdx}/${solveMoves.length})`;
  if(currentSolveIdx>=solveMoves.length){
    statusText.textContent='Solved!';setTimeout(clearArrow,speedMs);
    moveDisplay.innerHTML='<span class="mv current">✓ Done</span>';
  }
  updateBtnState();
}

async function stepBack(){
  if(isAnimating||currentSolveIdx<=0)return;
  currentSolveIdx--;
  const mv=solveMoves[currentSolveIdx],undoMv=invertMove(mv);
  updateMoveDisplay(solveMoves,currentSolveIdx);showArrow(undoMv);
  stepBtn.disabled=true;stepBackBtn.disabled=true;
  await executeMove(undoMv,speedMs);
  moveIdxEl.textContent=currentSolveIdx;
  statusText.textContent=`Solving (${currentSolveIdx}/${solveMoves.length})`;
  updateBtnState();
}

function doReset(){
  solving=false;isAnimating=false;
  scrambleMoves=[];solveMoves=[];currentSolveIdx=0;
  manualMoveCount=0;manualCountEl.textContent='0';
  manualSolution=[];manualHintIdx=0;hintDisplay.innerHTML='';
  buildCube();statusText.textContent='Ready';
  moveIdxEl.textContent='0';moveTotalEl.textContent='0';
  moveDisplay.innerHTML='';clearArrow();updateBtnState();
  setFaceBtnsEnabled(true);setDiffBtnsEnabled(true);
  document.getElementById('hintBtn').disabled=false;
}

function updateBtnState(){
  const fwd=solveMoves.length>0&&currentSolveIdx<solveMoves.length;
  const back=solveMoves.length>0&&currentSolveIdx>0;
  solveBtn.disabled=!fwd||solving||isAnimating;
  stepBtn.disabled=!fwd||solving||isAnimating;
  stepBackBtn.disabled=!back||solving||isAnimating;
}

// Manual face button handling
function setFaceBtnsEnabled(enabled){
  document.querySelectorAll('.face-btn').forEach(b=>b.disabled=!enabled);
}

async function doManualMove(notation){
  if(isAnimating||solving)return;
  setFaceBtnsEnabled(false);
  document.getElementById('hintBtn').disabled=true;
  showArrow(notation);
  statusText.textContent=MOVE_DESC[notation]||notation;
  await executeMove(notation,speedMs);
  manualMoveCount++;
  manualCountEl.textContent=manualMoveCount;
  updateHintTracking(notation);
  setFaceBtnsEnabled(true);
  document.getElementById('hintBtn').disabled=false;

  // Check if solved in manual mode
  if(manualMode && manualMoveCount>0 && checkSolved()){
    statusText.textContent='Solved!';
    clearArrow();
    setFaceBtnsEnabled(false);
    document.getElementById('hintBtn').disabled=true;
    hintDisplay.innerHTML='';
    launchConfetti();
  }
}

function checkSolved(){
  // Each cubie should be at its original position with identity rotation
  for(const c of cubies){
    const ep=new THREE.Vector3(c.ix*SPACING,c.iy*SPACING,c.iz*SPACING);
    if(c.mesh.position.distanceTo(ep)>0.01) return false;
  }
  // Check orientations: each cubie quaternion should be ~identity
  const identity=new THREE.Quaternion();
  for(const c of cubies){
    if(c.mesh.quaternion.angleTo(identity)>0.05) return false;
  }
  return true;
}

// Face buttons click
document.querySelectorAll('.face-btn').forEach(btn=>{
  btn.addEventListener('click',()=>{
    const mv=btn.dataset.move;
    if(mv) doManualMove(mv);
  });
});

// Cube zoom for manual mode (camera distance, no scale — avoids coordinate bugs)
const BASE_CAMERA_RADIUS = 7.5;
let currentCameraRadius = BASE_CAMERA_RADIUS;
function setCubeZoom(ratio){
  // ratio=1.0 → auto(기본), ratio>1 → 줌아웃(작게 보임)
  currentCameraRadius = BASE_CAMERA_RADIUS * ratio;
  updateCamera();
}

// Fanfare sound using Web Audio API
// Create AudioContext early on first user interaction so it's unlocked
let _audioCtx=null;
function getAudioCtx(){
  if(!_audioCtx) _audioCtx=new (window.AudioContext||window.webkitAudioContext)();
  return _audioCtx;
}
// Unlock audio on any user gesture
['click','touchstart','keydown'].forEach(evt=>{
  document.addEventListener(evt,function unlock(){
    const ac=getAudioCtx();
    if(ac.state==='suspended') ac.resume();
    document.removeEventListener(evt,unlock);
  },{once:true});
});

function playFanfare(){
  try{
    const ac=getAudioCtx();
    if(ac.state==='suspended') ac.resume();
    const now=ac.currentTime;
    // Bright trumpet-like fanfare: C5 E5 G5 C6
    const notes=[
      {freq:523.25,start:0,dur:0.2},
      {freq:659.25,start:0.18,dur:0.2},
      {freq:783.99,start:0.36,dur:0.2},
      {freq:1046.5,start:0.54,dur:0.55},
      // Harmony layer
      {freq:392.0,start:0,dur:0.2,gain:0.25},
      {freq:523.25,start:0.18,dur:0.2,gain:0.25},
      {freq:659.25,start:0.36,dur:0.2,gain:0.25},
      {freq:783.99,start:0.54,dur:0.55,gain:0.25},
    ];
    notes.forEach(n=>{
      const osc=ac.createOscillator();
      const gn=ac.createGain();
      const vol=n.gain||0.4;
      osc.type='square';
      osc.frequency.value=n.freq;
      gn.gain.setValueAtTime(0,now+n.start);
      gn.gain.linearRampToValueAtTime(vol,now+n.start+0.02);
      gn.gain.setValueAtTime(vol,now+n.start+n.dur*0.6);
      gn.gain.linearRampToValueAtTime(0,now+n.start+n.dur);
      osc.connect(gn);gn.connect(ac.destination);
      osc.start(now+n.start);osc.stop(now+n.start+n.dur+0.05);
    });
    // Sparkle shimmer
    for(let i=0;i<6;i++){
      const osc=ac.createOscillator();
      const gn=ac.createGain();
      osc.type='sine';
      osc.frequency.value=1800+Math.random()*2500;
      const t=0.6+i*0.09;
      gn.gain.setValueAtTime(0,now+t);
      gn.gain.linearRampToValueAtTime(0.1,now+t+0.02);
      gn.gain.linearRampToValueAtTime(0,now+t+0.18);
      osc.connect(gn);gn.connect(ac.destination);
      osc.start(now+t);osc.stop(now+t+0.25);
    }
  }catch(e){}
}

// Confetti celebration
function launchConfetti(){
  playFanfare();
  const canvas2=document.createElement('canvas');
  canvas2.className='confetti-overlay';
  canvas2.width=window.innerWidth;canvas2.height=window.innerHeight;
  document.body.appendChild(canvas2);
  const ctx=canvas2.getContext('2d');
  const colors=['#c41e3a','#ffd426','#009e60','#0051ba','#ff5800','#ff69b4','#FFD700','#00CED1'];
  const particles=[];
  for(let i=0;i<150;i++){
    particles.push({
      x:canvas2.width*0.5+(Math.random()-0.5)*100,
      y:canvas2.height*0.5,
      vx:(Math.random()-0.5)*12,
      vy:-(Math.random()*14+4),
      w:Math.random()*8+4,
      h:Math.random()*6+3,
      color:colors[Math.floor(Math.random()*colors.length)],
      rot:Math.random()*Math.PI*2,
      rotV:(Math.random()-0.5)*0.3,
      gravity:0.18+Math.random()*0.08,
      life:1
    });
  }
  // Show congratulations message
  const msg=document.createElement('div');
  msg.className='congrats-msg';
  msg.innerHTML='Congratulations!<span class="sub">Cube solved in '+manualMoveCount+' moves</span>';
  document.body.appendChild(msg);

  let frame=0;
  function tick(){
    ctx.clearRect(0,0,canvas2.width,canvas2.height);
    let alive=false;
    particles.forEach(p=>{
      p.x+=p.vx;p.y+=p.vy;p.vy+=p.gravity;
      p.rot+=p.rotV;
      p.vx*=0.99;
      if(frame>60) p.life-=0.015;
      if(p.life<=0)return;
      alive=true;
      ctx.save();ctx.translate(p.x,p.y);ctx.rotate(p.rot);
      ctx.globalAlpha=Math.max(0,p.life);
      ctx.fillStyle=p.color;
      ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);
      ctx.restore();
    });
    frame++;
    if(alive&&frame<300){requestAnimationFrame(tick);}
    else{
      canvas2.remove();
      msg.style.animation='congratsFade 0.5s ease forwards';
      setTimeout(()=>msg.remove(),600);
    }
  }
  requestAnimationFrame(tick);
}

// Mode toggle
const modeAutoBtn=document.getElementById('modeAuto');
const modeManualBtn=document.getElementById('modeManual');

modeAutoBtn.addEventListener('click',()=>{
  manualMode=false;
  document.body.classList.remove('manual-mode');
  modeAutoBtn.classList.add('active');
  modeManualBtn.classList.remove('active');
  setCubeZoom(1.0);
  requestAnimationFrame(resize);
});
modeManualBtn.addEventListener('click',()=>{
  manualMode=true;
  document.body.classList.add('manual-mode');
  modeManualBtn.classList.add('active');
  modeAutoBtn.classList.remove('active');
  setCubeZoom(1.18);
  setFaceBtnsEnabled(true);
  requestAnimationFrame(resize);
});

// Speed
let speedMs=800;
const speedSlider=document.getElementById('speedSlider');
const speedValEl=document.getElementById('speedVal');
const statusText=document.getElementById('statusText');
const moveIdxEl=document.getElementById('moveIdx');
const moveTotalEl=document.getElementById('moveTotal');
const stepBackBtn=document.getElementById('stepBackBtn');
const scrambleBtn=document.getElementById('scrambleBtn');

function updateSpeed(){
  const v=parseInt(speedSlider.value);
  speedMs=Math.round(1500-(v-1)*150);
  speedValEl.textContent=(speedMs/1000).toFixed(1)+'s';
}
speedSlider.addEventListener('input',updateSpeed);

scrambleBtn.addEventListener('click',doScramble);
document.getElementById('solveBtn').addEventListener('click',animateSolve);
document.getElementById('stepBtn').addEventListener('click',stepOnce);
stepBackBtn.addEventListener('click',stepBack);
document.getElementById('resetBtn').addEventListener('click',doReset);

// Manual difficulty scramble buttons
document.getElementById('diffEasy').addEventListener('click',()=>doManualScramble(4+Math.floor(Math.random()*2)));
document.getElementById('diffModerate').addEventListener('click',()=>doManualScramble(6+Math.floor(Math.random()*3)));
document.getElementById('diffHard').addEventListener('click',()=>doManualScramble(10+Math.floor(Math.random()*3)));
document.getElementById('hintBtn').addEventListener('click',showHint);

// Keyboard shortcuts for manual mode
window.addEventListener('keydown',e=>{
  if(isAnimating||solving)return;
  const key=e.key.toUpperCase();
  const shift=e.shiftKey;
  if(['U','D','F','B','R','L'].includes(key)){
    e.preventDefault();
    doManualMove(shift?key+"'":key);
  }
});

buildCube();updateCamera();updateSpeed();renderLoop();
requestAnimationFrame(()=>{resize();requestAnimationFrame(resize);});
</script>
</body>
</html>
